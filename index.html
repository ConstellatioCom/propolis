<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphe de mots-clés PROPOLIS Agrandie</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Styles pour un affichage plein écran du graphe */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; 
            background-color: #f3f4f6;
        }

        /* Conteneur et SVG prennent 100% de l'espace disponible */
        #chart-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #star-graph {
            width: 100%;
            height: 100%;
        }
        
        /* Tooltip style */
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 0.5rem;
            font-size: 0.875rem;
            background: #1f2937;
            color: white;
            border-radius: 0.5rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 300px;
        }
        /* Styles des éléments du graphe */
        .node text {
            pointer-events: none;
            font-size: 11px;
            fill: #374151;
            font-weight: 500;
            text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.7);
        }
        .link {
            stroke: #9ca3af;
            stroke-opacity: 0.6;
            stroke-width: 2px;
        }
        .central-node circle {
            stroke: #A0522D;
            stroke-width: 4px !important;
        }
    </style>
</head>
<body>

    <div id="chart-container"><svg id="star-graph"></svg></div>
    <div id="tooltip" class="tooltip"></div>

    <script>
        // --- Données pour le graphe en étoile PROPOLIS ---
        const nodesData = [
            { id: 'PROPOLIS', category: 'Centre', type: 'central' },
            // 1. Marque (Bleu)
            { id: 'propolis ingénierie', category: 'Marque', type: 'keyword' },
            { id: 'propolis engineering', category: 'Marque', type: 'keyword' },
            { id: 'cabinet propolis', category: 'Marque', type: 'keyword' },
            { id: 'propolis nanterre', category: 'Marque', type: 'keyword' },
            // 2. Expertise Spécifique (Vert)
            { id: 'propolis sûreté', category: 'Expertise Spécifique', type: 'keyword' },
            { id: 'propolis sécurité', category: 'Expertise Spécifique', type: 'keyword' },
            { id: 'propolis ingénierie sûreté', category: 'Expertise Spécifique', type: 'keyword' },
            { id: 'propolis audit sécurité', category: 'Expertise Spécifique', type: 'keyword' },
            // 3. Transactionnel (Orange)
            { id: 'propolis contact', category: 'Transactionnel', type: 'keyword' },
            { id: 'propolis téléphone', category: 'Transactionnel', type: 'keyword' },
            { id: 'propolis adresse', category: 'Transactionnel', type: 'keyword' },
            { id: 'propolis avis', category: 'Transactionnel', type: 'keyword' },
            { id: 'propolis recrutement', category: 'Transactionnel', type: 'keyword' },
        ];

        const linksData = nodesData.filter(d => d.type === 'keyword').map(d => ({
            source: 'PROPOLIS',
            target: d.id,
        }));

        const colorScale = d3.scaleOrdinal()
            .domain(['Centre', 'Marque', 'Expertise Spécifique', 'Transactionnel'])
            .range(['#A0522D', '#4285F4', '#34A853', '#FBBC04']);

        const tooltip = d3.select("#tooltip");

        // --- Fonction de rendu du graphe ---
        function renderStarGraph() {
            const svg = d3.select("#star-graph");
            const width = window.innerWidth;
            const height = window.innerHeight;
            svg.attr("width", width).attr("height", height);
            svg.selectAll("*").remove();

            // Mapping des catégories vers des positions de groupement (clusters)
            const getGroupPosition = (category) => {
                // Augmentation de la marge pour agrandir le graphe
                const margin = Math.min(width, height) / 3.5; 
                const centerX = width / 2;
                const centerY = height / 2;
                
                switch (category) {
                    case 'Marque': return { x: centerX - margin * 1.5, y: centerY - margin * 0.8 }; // Position plus éloignée
                    case 'Expertise Spécifique': return { x: centerX - margin * 0.5, y: centerY + margin * 1.5 }; // Position plus éloignée
                    case 'Transactionnel': return { x: centerX + margin * 1.5, y: centerY - margin * 0.8 }; // Position plus éloignée
                    case 'Centre': return { x: centerX, y: centerY };
                    default: return { x: centerX, y: centerY };
                }
            };

            // Simulation de force D3
            const simulation = d3.forceSimulation(nodesData)
                // Augmentation de la distance de repos des liens
                .force("link", d3.forceLink(linksData).id(d => d.id).distance(100).strength(0.8)) 
                // Augmentation de la répulsion pour séparer les clusters
                .force("charge", d3.forceManyBody().strength(-400)) 
                .force("center", d3.forceCenter(width / 2, height / 2).strength(0.1))

                // Force de groupement
                .force("x", d3.forceX(d => getGroupPosition(d.category).x).strength(d => d.type === 'central' ? 0.8 : 0.2))
                .force("y", d3.forceY(d => getGroupPosition(d.category).y).strength(d => d.type === 'central' ? 0.8 : 0.2))

                // Maintien de la taille des nœuds
                .force("collide", d3.forceCollide().radius(d => (d.type === 'central' ? 35 : 20))); 

            const link = svg.append("g").selectAll("line")
                .data(linksData)
                .join("line")
                .attr("class", "link");

            const node = svg.append("g").selectAll("g")
                .data(nodesData)
                .join("g")
                .attr("class", d => `node ${d.type === 'central' ? 'central-node' : ''}`)
                .call(drag(simulation));

            // Cercles des nœuds (taille maintenue)
            node.append("circle")
                .attr("r", d => d.type === 'central' ? 30 : 18)
                .attr("fill", d => colorScale(d.category))
                .attr("stroke", "#fff")
                .attr("stroke-width", 2);

            // Texte des nœuds (taille maintenue)
            node.append("text")
                .text(d => d.id)
                .attr("x", d => d.type === 'central' ? 35 : 22)
                .attr("y", 5)
                .attr("fill", "#374151")
                .style("font-size", d => d.type === 'central' ? '14px' : '11px');

            // Interactivité (Tooltip)
            node.on("mouseover", (event, d) => {
                const radius = d.type === 'central' ? 35 : 22;
                d3.select(event.currentTarget).select("circle").transition().duration(150).attr("r", radius);
                tooltip.style("opacity", 1).html(`
                    <strong>${d.id}</strong><br>
                    <span style="color:${colorScale(d.category)};">
                        Catégorie : ${d.category}
                    </span>
                `);
            })
            .on("mousemove", (event) => {
                tooltip.style("left", (event.pageX + 15) + "px").style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", (event, d) => {
                const radius = d.type === 'central' ? 30 : 18;
                d3.select(event.currentTarget).select("circle").transition().duration(150).attr("r", radius);
                tooltip.style("opacity", 0);
            });

            // Mise à jour de la position à chaque "tick"
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node.attr("transform", d => `translate(${d.x},${d.y})`);
            });

            // Fonction de drag pour fixer les nœuds
            function drag(simulation) {
                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }
                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                }
                return d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended);
            }
        }

        // --- Rendu initial et redimensionnement ---
        window.addEventListener('load', renderStarGraph);
        window.addEventListener('resize', renderStarGraph);

    </script>
</body>
</html>
